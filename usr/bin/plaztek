#!/bin/bash

# Plaztek - User-based lightweight sandbox system
# Uses bubblewrap to create secure sandboxes for running untrusted scripts and projects
# developed by root0emir

set -euo pipefail


CONFIG_DIR="/etc/plaztek.d"
PROFILES_DIR="/etc/plaztek.d/profiles"
TMP_DIR="/tmp/plaztek-$$"
VERSION="1.3.0"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' 


NETWORK_ENABLED=true
DIR_MODE=false
WRITABLE_MODE=false
DRY_RUN_MODE=false
LIST_CONFIGS=false
TARGET_PATH=""
COMMAND_ARGS=()
BLOCKED_PATHS=()
EPHEMERAL_DIR=""
CUSTOM_CONFIGS=()
LOADED_CONFIGS=()
BWRAP_EXTRA_ARGS=()
BWRAP_CMD=()
PROFILE=""


show_usage() {
    cat << EOF
Plaztek v${VERSION} - Lightweight Sandbox System

Usage: plaztek [OPTIONS] [TARGET] [-- COMMAND]

BASIC OPTIONS:
    --profile PROFILE  Use security profile (basic|medium|strict|paronid)
    --config NAME      Load configuration file (NAME.conf) - can be used multiple times
    --enable-network   Enable network access (default)
    --disable-network  Disable network access
    --dir              Treat target as directory to sandbox
    --writable         Create ephemeral copy for write access

ADVANCED OPTIONS:
    --dry-run          Show what would be executed without running
    --list-configs     List all available configuration files
    --bwrap-arg ARG    Pass additional argument to bubblewrap

SYSTEM OPTIONS:
    --help, -h         Show this help message
    --version, -v      Show version information

EXAMPLES:
    plaztek --profile paronid suspicious_script.sh
    plaztek --profile strict --disable-network --dir ~/downloads/ProjectX
    plaztek --profile medium --writable --dir ~/myproject -- /bin/bash
    plaztek --config applications script.py
    plaztek --config critical --config services --config security script.py
    plaztek --config mycustom --verbose script.sh

PROFILES:
    basic    - Block only critical system files
    medium   - Medium level security, suitable for development
    strict   - Strict security for untrusted code
    paronid  - Maximum security with heaviest restrictions

CONFIGURATION:
    Config files: ${CONFIG_DIR}/
    Profile files: ${PROFILES_DIR}/
    Create custom: /etc/plaztek.d/myconfig.conf
    Each .conf file contains paths to block, one per line.

EOF
}

show_version() {
    echo "Plaztek v${VERSION}"
    echo "Lightweight sandbox system using bubblewrap"
    echo "Configuration directory: ${CONFIG_DIR}"
    echo "Profiles directory: ${PROFILES_DIR}"
}

list_configs() {
    echo -e "${CYAN}Available Configuration Files:${NC}"
    
    echo -e "${PURPLE}Security Profiles:${NC}"
    if [ -d "$PROFILES_DIR" ]; then
        for profile in basic medium strict paronid; do
            if [ -f "$PROFILES_DIR/$profile.conf" ]; then
                local count=$(grep -v '^#\|^$' "$PROFILES_DIR/$profile.conf" 2>/dev/null | wc -l)
                echo "  $profile ($count paths)"
            fi
        done
    else
        echo "  No profiles found"
    fi
    
    echo
    echo -e "${PURPLE}Configuration Files:${NC}"
    if [ -d "$CONFIG_DIR" ]; then
        for conf in "$CONFIG_DIR"/*.conf; do
            if [ -f "$conf" ]; then
                local name=$(basename "$conf" .conf)
                local count=$(grep -v '^#\|^$' "$conf" 2>/dev/null | wc -l)
                echo "  $name ($count paths)"
            fi
        done
    else
        echo "  No configurations found"
    fi
    
    echo
    echo -e "${CYAN}Usage:${NC}"
    echo "  --profile PROFILE    Use security profile"
    echo "  --config NAME        Use configuration file"
    echo "  Create custom:       /etc/plaztek.d/myconfig.conf"
    echo
    echo -e "${YELLOW}Note: Profile and config cannot be used together${NC}"
}

check_dependencies() {
    local missing_deps=()
    
    if ! command -v bwrap &> /dev/null; then
        missing_deps+=("bubblewrap")
    fi
    
    if ! command -v realpath &> /dev/null; then
        missing_deps+=("coreutils")
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo "Error: Missing required dependencies: ${missing_deps[*]}" >&2
        echo "Please install: sudo apt install bubblewrap coreutils" >&2
        exit 1
    fi
    
    # Check user namespace support
    if [ -f /proc/sys/kernel/unprivileged_userns_clone ]; then
        local userns_enabled
        userns_enabled=$(cat /proc/sys/kernel/unprivileged_userns_clone 2>/dev/null)
        if [ "$userns_enabled" != "1" ]; then
            echo "Warning: Unprivileged user namespaces are disabled." >&2
            echo "This may affect bubblewrap functionality. Consider enabling with:" >&2
            echo "  sudo sysctl kernel.unprivileged_userns_clone=1" >&2
            echo "Or add 'kernel.unprivileged_userns_clone=1' to /etc/sysctl.conf" >&2
        fi
    fi
    
}
load_config() {
    local config_file="$1"
    local config_path="$2"
    
    if [ ! -f "$config_path" ]; then
        echo "Warning: Configuration file not found: $config_path" >&2
        return 1
    fi
    
    LOADED_CONFIGS+=("$config_file")
    
    local line_count=0
    local path_count=0
    
    while IFS= read -r line; do
        line_count=$((line_count + 1))
        
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Trim whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip empty lines after trimming
        [[ -z "$line" ]] && continue
        
        # Validate path format
        if [[ ! "$line" =~ ^/ ]]; then
            echo "Warning: $config_file:$line_count: Path should be absolute: $line" >&2
            continue
        fi
        
        # Handle wildcards safely to prevent TOCTOU and symlink attacks
        if [[ "$line" == *"*"* ]]; then
            # Use find instead of shell expansion for safer wildcard handling
            local expanded_paths=()
            local base_dir=$(dirname "$line")
            local pattern=$(basename "$line")
            
            # Only expand if base directory exists and is not a symlink
            if [ -d "$base_dir" ] && [ ! -L "$base_dir" ]; then
                # Use find with maxdepth 1 to avoid deep traversal
                while IFS= read -r -d '' found_path; do
                    # Verify the path is still valid and not a symlink to outside sandbox
                    if [ -e "$found_path" ] && [[ "$found_path" == "$base_dir"/* ]]; then
                        expanded_paths+=("$found_path")
                        path_count=$((path_count + 1))
                    fi
                done < <(find "$base_dir" -maxdepth 1 -name "$pattern" -print0 2>/dev/null)
            fi
            
            if [ ${#expanded_paths[@]} -gt 0 ]; then
                BLOCKED_PATHS+=("${expanded_paths[@]}")
            else
                echo "Warning: $config_file:$line_count: No matches found for pattern: $line" >&2
            fi
        else
            # Validate that the path is not a symlink pointing outside expected areas
            if [ -L "$line" ]; then
                local real_path
                real_path=$(realpath "$line" 2>/dev/null) || {
                    echo "Warning: $config_file:$line_count: Cannot resolve symlink: $line" >&2
                    continue
                }
                # Check if symlink points to a safe location
                # Allow system directories and standard locations
                if [[ "$real_path" != /home/* ]] && [[ "$real_path" != /tmp/* ]] && [[ "$real_path" != /var/tmp/* ]] && \
                   [[ "$real_path" != /usr/* ]] && [[ "$real_path" != /bin/* ]] && [[ "$real_path" != /sbin/* ]] && \
                   [[ "$real_path" != /lib/* ]] && [[ "$real_path" != /etc/* ]]; then
                    echo "Warning: $config_file:$line_count: Symlink points to potentially unsafe location: $line -> $real_path" >&2
                fi
            fi
            BLOCKED_PATHS+=("$line")
            path_count=$((path_count + 1))
        fi
    done < "$config_path"
    
}

check_dependencies() {
    local missing_deps=()
    
    if ! command -v bwrap &> /dev/null; then
        missing_deps+=("bubblewrap")
    fi
    
    if ! command -v realpath &> /dev/null; then
        missing_deps+=("coreutils")
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo "Error: Missing required dependencies: ${missing_deps[*]}" >&2
        echo "Please install: sudo apt install bubblewrap coreutils" >&2
        exit 1
    fi
    
    # Check user namespace support
    if [ -f /proc/sys/kernel/unprivileged_userns_clone ]; then
        local userns_enabled
        userns_enabled=$(cat /proc/sys/kernel/unprivileged_userns_clone 2>/dev/null)
        if [ "$userns_enabled" != "1" ]; then
            echo "Warning: Unprivileged user namespaces are disabled." >&2
            echo "This may affect bubblewrap functionality. Consider enabling with:" >&2
            echo "  sudo sysctl kernel.unprivileged_userns_clone=1" >&2
            echo "Or add 'kernel.unprivileged_userns_clone=1' to /etc/sysctl.conf" >&2
        fi
    fi
    
}

create_ephemeral_copy() {
    local source_dir="$1"
    local temp_base="/tmp/plaztek-ephemeral-$$"
    
    echo "Creating ephemeral copy of: $source_dir"
    
    if [ ! -d "$source_dir" ]; then
        echo "Error: Source directory does not exist: $source_dir" >&2
        exit 1
    fi
    
    # Check available space
    local source_size=$(du -sb "$source_dir" | cut -f1)
    local available_space=$(df /tmp | tail -1 | awk '{print $4 * 1024}')
    
    if [ "$source_size" -gt "$available_space" ]; then
        echo "Error: Not enough space in /tmp for ephemeral copy" >&2
        echo "Required: $(numfmt --to=iec $source_size), Available: $(numfmt --to=iec $available_space)" >&2
        exit 1
    fi
    
    mkdir -p "$temp_base"
    
    # Use rsync if available for better progress and error handling
    if command -v rsync &> /dev/null; then
        rsync -a "$source_dir"/ "$temp_base"/
    else
        cp -r "$source_dir"/* "$temp_base"/ 2>/dev/null || true
        cp -r "$source_dir"/.[^.]* "$temp_base"/ 2>/dev/null || true
    fi
    
    EPHEMERAL_DIR="$temp_base"
    echo "Ephemeral copy created at: $EPHEMERAL_DIR"
}

cleanup() {
    local exit_code=$?
    
    if [ -n "$EPHEMERAL_DIR" ] && [ -d "$EPHEMERAL_DIR" ]; then
        rm -rf "$EPHEMERAL_DIR" 2>/dev/null || true
    fi
    
    if [ -d "$TMP_DIR" ]; then
        rm -rf "$TMP_DIR" 2>/dev/null || true
    fi
    
    exit $exit_code
}

# Set up signal handlers
trap cleanup EXIT INT TERM

# Validate blocked paths and remove duplicates
validate_blocked_paths() {
    local unique_paths=()
    local seen_paths=()
    
    for path in "${BLOCKED_PATHS[@]}"; do
        # Skip if already seen
        local already_seen=false
        for seen in "${seen_paths[@]}"; do
            if [ "$path" = "$seen" ]; then
                already_seen=true
                break
            fi
        done
        
        if [ "$already_seen" = false ]; then
            unique_paths+=("$path")
            seen_paths+=("$path")
        fi
    done
    
    BLOCKED_PATHS=("${unique_paths[@]}")
}

build_bwrap_command() {
    BWRAP_CMD=("bwrap")
    
    BWRAP_CMD+=("--dev-bind" "/dev" "/dev")
    BWRAP_CMD+=("--proc" "/proc")
    BWRAP_CMD+=("--tmpfs" "/tmp")
    
    local essential_dirs=("/usr" "/lib" "/lib64" "/bin" "/sbin")
    for dir in "${essential_dirs[@]}"; do
        if [ -d "$dir" ]; then
            BWRAP_CMD+=("--ro-bind" "$dir" "$dir")
        fi
    done
    
    # More selective /etc binding - only bind essential files
    if [ -d "/etc" ]; then
        local essential_etc_files=("/etc/passwd" "/etc/group" "/etc/hosts" "/etc/resolv.conf" "/etc/nsswitch.conf" "/etc/ld.so.conf" "/etc/ld.so.cache")
        for etc_file in "${essential_etc_files[@]}"; do
            if [ -f "$etc_file" ]; then
                BWRAP_CMD+=("--ro-bind" "$etc_file" "$etc_file")
            fi
        done
        
        # Bind essential directories from /etc
        local essential_etc_dirs=("/etc/ssl" "/etc/ca-certificates")
        for etc_dir in "${essential_etc_dirs[@]}"; do
            if [ -d "$etc_dir" ]; then
                BWRAP_CMD+=("--ro-bind" "$etc_dir" "$etc_dir")
            fi
        done
    fi
    
    # More selective HOME binding - create minimal home environment
    if [ -n "$HOME" ] && [ -d "$HOME" ]; then
        # Create a minimal home directory structure
        mkdir -p "$TMP_DIR/home"
        BWRAP_CMD+=("--bind" "$TMP_DIR/home" "$HOME")
        
        # Only bind specific safe directories if they exist
        local safe_home_dirs=(".cache" ".local/share" ".config")
        for safe_dir in "${safe_home_dirs[@]}"; do
            if [ -d "$HOME/$safe_dir" ]; then
                mkdir -p "$TMP_DIR/home/$safe_dir"
                BWRAP_CMD+=("--bind" "$HOME/$safe_dir" "$HOME/$safe_dir")
            fi
        done
    fi
    
    local blocked_count=0
    for blocked_path in "${BLOCKED_PATHS[@]}"; do
        if [ -e "$blocked_path" ] || [ -L "$blocked_path" ]; then
            if [ -d "$blocked_path" ]; then
                BWRAP_CMD+=("--tmpfs" "$blocked_path")
                blocked_count=$((blocked_count + 1))
            elif [ -f "$blocked_path" ]; then
                # Create an empty file instead of binding /dev/null
                local empty_file="$TMP_DIR/empty_file_$(basename "$blocked_path")"
                touch "$empty_file"
                BWRAP_CMD+=("--ro-bind" "$empty_file" "$blocked_path")
                blocked_count=$((blocked_count + 1))
            fi
        fi
    done
    
    if [ "$NETWORK_ENABLED" = false ]; then
        BWRAP_CMD+=("--unshare-net")
    fi
    
    if [ ${#BWRAP_EXTRA_ARGS[@]} -gt 0 ]; then
        BWRAP_CMD+=("${BWRAP_EXTRA_ARGS[@]}")
    fi
    
    if [ "$DIR_MODE" = true ]; then
        local target_dir="$TARGET_PATH"
        
        if [ "$WRITABLE_MODE" = true ]; then
            if [ -z "$EPHEMERAL_DIR" ]; then
                create_ephemeral_copy "$target_dir"
            fi
            target_dir="$EPHEMERAL_DIR"
            BWRAP_CMD+=("--bind" "$target_dir" "$target_dir")
        else
            BWRAP_CMD+=("--ro-bind" "$target_dir" "$target_dir")
        fi
        
        BWRAP_CMD+=("--chdir" "$target_dir")
    elif [ -n "$TARGET_PATH" ]; then
        local target_dir
        target_dir=$(dirname "$TARGET_PATH")
        BWRAP_CMD+=("--ro-bind" "$target_dir" "$target_dir")
        BWRAP_CMD+=("--chdir" "$target_dir")
    fi
    
    if [ ${#COMMAND_ARGS[@]} -gt 0 ]; then
        BWRAP_CMD+=("${COMMAND_ARGS[@]}")
    elif [ -n "$TARGET_PATH" ] && [ "$DIR_MODE" = false ]; then
        local interpreter
        case "$TARGET_PATH" in
            *.py)
                interpreter="python3"
                ;;
            *.py2)
                interpreter="python2"
                ;;
            *.sh|*.bash)
                interpreter="bash"
                ;;
            *.js)
                interpreter="node"
                ;;
            *.rb)
                interpreter="ruby"
                ;;
            *.pl)
                interpreter="perl"
                ;;
            *.php)
                interpreter="php"
                ;;
            *)
                if [ -x "$TARGET_PATH" ]; then
                    interpreter="$TARGET_PATH"
                else
                    interpreter="bash"
                fi
                ;;
        esac
        BWRAP_CMD+=("$interpreter" "$TARGET_PATH")
    else
        BWRAP_CMD+=("bash")
    fi
}

parse_arguments() {
    local parsing_options=true
    
    while [ $# -gt 0 ]; do
        if [ "$parsing_options" = true ]; then
            case "$1" in
                --profile)
                    if [ $# -lt 2 ]; then
                        echo "Error: --profile requires a profile name" >&2
                        exit 1
                    fi
                    if [ ${#CUSTOM_CONFIGS[@]} -gt 0 ]; then
                        echo "Error: Cannot use --profile and --config together" >&2
                        exit 1
                    fi
                    case "$2" in
                        basic|medium|strict|paronid)
                            PROFILE="$2"
                            ;;
                        *)
                            echo "Error: Invalid profile: $2. Valid profiles: basic, medium, strict, paronid" >&2
                            exit 1
                            ;;
                    esac
                    shift 2
                    ;;
                --config)
                    if [ $# -lt 2 ]; then
                        echo "Error: --config requires a configuration name" >&2
                        exit 1
                    fi
                    if [ -n "$PROFILE" ]; then
                        echo "Error: Cannot use --profile and --config together" >&2
                        exit 1
                    fi
                    CUSTOM_CONFIGS+=("$2")
                    shift 2
                    ;;
                --enable-network)
                    NETWORK_ENABLED=true
                    shift
                    ;;
                --disable-network)
                    NETWORK_ENABLED=false
                    shift
                    ;;
                --dir)
                    DIR_MODE=true
                    shift
                    ;;
                --writable)
                    WRITABLE_MODE=true
                    shift
                    ;;
                --dry-run)
                    DRY_RUN_MODE=true
                    shift
                    ;;
                --bwrap-arg)
                    if [ $# -lt 2 ]; then
                        echo "Error: --bwrap-arg requires an argument" >&2
                        exit 1
                    fi
                    BWRAP_EXTRA_ARGS+=("$2")
                    shift 2
                    ;;
                --list-configs)
                    LIST_CONFIGS=true
                    shift
                    ;;
                --help|-h)
                    show_usage
                    exit 0
                    ;;
                --version|-v)
                    show_version
                    exit 0
                    ;;
                --)
                    parsing_options=false
                    shift
                    ;;
                -*)
                    echo "Error: Unknown option: $1" >&2
                    show_usage
                    exit 1
                    ;;
                *)
                    if [ -z "$TARGET_PATH" ]; then
                        TARGET_PATH="$1"
                    else
                        COMMAND_ARGS+=("$1")
                    fi
                    shift
                    ;;
            esac
        else
            COMMAND_ARGS+=("$1")
            shift
        fi
    done
}

main() {
    
    parse_arguments "$@"
    
    if [ "$LIST_CONFIGS" = true ]; then
        list_configs
        exit 0
    fi
    
    check_dependencies
    
    if [ -n "$TARGET_PATH" ]; then
        if [ "$DIR_MODE" = true ]; then
            if [ ! -d "$TARGET_PATH" ]; then
                echo "Error: Directory not found: $TARGET_PATH" >&2
                exit 1
            fi
        else
            if [ ! -f "$TARGET_PATH" ]; then
                echo "Error: File not found: $TARGET_PATH" >&2
                exit 1
            fi
        fi
        
        TARGET_PATH=$(realpath "$TARGET_PATH")
    fi
    
    if [ -n "$PROFILE" ]; then
        load_config "$PROFILE" "$PROFILES_DIR/${PROFILE}.conf" || {
            echo "Error: Failed to load profile: $PROFILE" >&2
            exit 1
        }
    fi
    
    for config_name in "${CUSTOM_CONFIGS[@]}"; do
        load_config "$config_name" "$CONFIG_DIR/${config_name}.conf" || {
            echo "Error: Failed to load configuration: $config_name" >&2
            exit 1
        }
    done
    
    if [ -z "$PROFILE" ] && [ ${#CUSTOM_CONFIGS[@]} -eq 0 ]; then
        load_config "ssh" "$CONFIG_DIR/ssh.conf" || true
    fi
    
    validate_blocked_paths
    
    
    
    # Ensure TMP_DIR exists
    mkdir -p "$TMP_DIR"
    
    if [ "$WRITABLE_MODE" = true ] && [ "$DIR_MODE" = true ]; then
        create_ephemeral_copy "$TARGET_PATH"
    fi
    
    build_bwrap_command
    
    if [ "$DRY_RUN_MODE" = true ]; then
        echo "DRY RUN - Would execute:"
        printf '%q ' "${BWRAP_CMD[@]}"
        echo
        exit 0
    fi
    
    exec "${BWRAP_CMD[@]}"
}

main "$@"
